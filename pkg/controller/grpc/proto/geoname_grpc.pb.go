// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: api/grpc/geoname.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GeoNameServiceClient is the client API for GeoNameService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GeoNameServiceClient interface {
	Continent(ctx context.Context, in *GeoNameRequest, opts ...grpc.CallOption) (GeoNameService_ContinentClient, error)
	Country(ctx context.Context, in *GeoNameRequest, opts ...grpc.CallOption) (GeoNameService_CountryClient, error)
	City(ctx context.Context, in *GeoNameRequest, opts ...grpc.CallOption) (GeoNameService_CityClient, error)
	Subdivision(ctx context.Context, in *GeoNameRequest, opts ...grpc.CallOption) (GeoNameService_SubdivisionClient, error)
}

type geoNameServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGeoNameServiceClient(cc grpc.ClientConnInterface) GeoNameServiceClient {
	return &geoNameServiceClient{cc}
}

func (c *geoNameServiceClient) Continent(ctx context.Context, in *GeoNameRequest, opts ...grpc.CallOption) (GeoNameService_ContinentClient, error) {
	stream, err := c.cc.NewStream(ctx, &GeoNameService_ServiceDesc.Streams[0], "/geoname.GeoNameService/Continent", opts...)
	if err != nil {
		return nil, err
	}
	x := &geoNameServiceContinentClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GeoNameService_ContinentClient interface {
	Recv() (*GeoNameContinentResponse, error)
	grpc.ClientStream
}

type geoNameServiceContinentClient struct {
	grpc.ClientStream
}

func (x *geoNameServiceContinentClient) Recv() (*GeoNameContinentResponse, error) {
	m := new(GeoNameContinentResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geoNameServiceClient) Country(ctx context.Context, in *GeoNameRequest, opts ...grpc.CallOption) (GeoNameService_CountryClient, error) {
	stream, err := c.cc.NewStream(ctx, &GeoNameService_ServiceDesc.Streams[1], "/geoname.GeoNameService/Country", opts...)
	if err != nil {
		return nil, err
	}
	x := &geoNameServiceCountryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GeoNameService_CountryClient interface {
	Recv() (*GeoNameCountryResponse, error)
	grpc.ClientStream
}

type geoNameServiceCountryClient struct {
	grpc.ClientStream
}

func (x *geoNameServiceCountryClient) Recv() (*GeoNameCountryResponse, error) {
	m := new(GeoNameCountryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geoNameServiceClient) City(ctx context.Context, in *GeoNameRequest, opts ...grpc.CallOption) (GeoNameService_CityClient, error) {
	stream, err := c.cc.NewStream(ctx, &GeoNameService_ServiceDesc.Streams[2], "/geoname.GeoNameService/City", opts...)
	if err != nil {
		return nil, err
	}
	x := &geoNameServiceCityClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GeoNameService_CityClient interface {
	Recv() (*GeoNameCityResponse, error)
	grpc.ClientStream
}

type geoNameServiceCityClient struct {
	grpc.ClientStream
}

func (x *geoNameServiceCityClient) Recv() (*GeoNameCityResponse, error) {
	m := new(GeoNameCityResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geoNameServiceClient) Subdivision(ctx context.Context, in *GeoNameRequest, opts ...grpc.CallOption) (GeoNameService_SubdivisionClient, error) {
	stream, err := c.cc.NewStream(ctx, &GeoNameService_ServiceDesc.Streams[3], "/geoname.GeoNameService/Subdivision", opts...)
	if err != nil {
		return nil, err
	}
	x := &geoNameServiceSubdivisionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GeoNameService_SubdivisionClient interface {
	Recv() (*GeoNameSubdivisionResponse, error)
	grpc.ClientStream
}

type geoNameServiceSubdivisionClient struct {
	grpc.ClientStream
}

func (x *geoNameServiceSubdivisionClient) Recv() (*GeoNameSubdivisionResponse, error) {
	m := new(GeoNameSubdivisionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GeoNameServiceServer is the server API for GeoNameService service.
// All implementations must embed UnimplementedGeoNameServiceServer
// for forward compatibility
type GeoNameServiceServer interface {
	Continent(*GeoNameRequest, GeoNameService_ContinentServer) error
	Country(*GeoNameRequest, GeoNameService_CountryServer) error
	City(*GeoNameRequest, GeoNameService_CityServer) error
	Subdivision(*GeoNameRequest, GeoNameService_SubdivisionServer) error
	mustEmbedUnimplementedGeoNameServiceServer()
}

// UnimplementedGeoNameServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGeoNameServiceServer struct {
}

func (UnimplementedGeoNameServiceServer) Continent(*GeoNameRequest, GeoNameService_ContinentServer) error {
	return status.Errorf(codes.Unimplemented, "method Continent not implemented")
}
func (UnimplementedGeoNameServiceServer) Country(*GeoNameRequest, GeoNameService_CountryServer) error {
	return status.Errorf(codes.Unimplemented, "method Country not implemented")
}
func (UnimplementedGeoNameServiceServer) City(*GeoNameRequest, GeoNameService_CityServer) error {
	return status.Errorf(codes.Unimplemented, "method City not implemented")
}
func (UnimplementedGeoNameServiceServer) Subdivision(*GeoNameRequest, GeoNameService_SubdivisionServer) error {
	return status.Errorf(codes.Unimplemented, "method Subdivision not implemented")
}
func (UnimplementedGeoNameServiceServer) mustEmbedUnimplementedGeoNameServiceServer() {}

// UnsafeGeoNameServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeoNameServiceServer will
// result in compilation errors.
type UnsafeGeoNameServiceServer interface {
	mustEmbedUnimplementedGeoNameServiceServer()
}

func RegisterGeoNameServiceServer(s grpc.ServiceRegistrar, srv GeoNameServiceServer) {
	s.RegisterService(&GeoNameService_ServiceDesc, srv)
}

func _GeoNameService_Continent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GeoNameRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeoNameServiceServer).Continent(m, &geoNameServiceContinentServer{stream})
}

type GeoNameService_ContinentServer interface {
	Send(*GeoNameContinentResponse) error
	grpc.ServerStream
}

type geoNameServiceContinentServer struct {
	grpc.ServerStream
}

func (x *geoNameServiceContinentServer) Send(m *GeoNameContinentResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _GeoNameService_Country_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GeoNameRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeoNameServiceServer).Country(m, &geoNameServiceCountryServer{stream})
}

type GeoNameService_CountryServer interface {
	Send(*GeoNameCountryResponse) error
	grpc.ServerStream
}

type geoNameServiceCountryServer struct {
	grpc.ServerStream
}

func (x *geoNameServiceCountryServer) Send(m *GeoNameCountryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _GeoNameService_City_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GeoNameRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeoNameServiceServer).City(m, &geoNameServiceCityServer{stream})
}

type GeoNameService_CityServer interface {
	Send(*GeoNameCityResponse) error
	grpc.ServerStream
}

type geoNameServiceCityServer struct {
	grpc.ServerStream
}

func (x *geoNameServiceCityServer) Send(m *GeoNameCityResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _GeoNameService_Subdivision_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GeoNameRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeoNameServiceServer).Subdivision(m, &geoNameServiceSubdivisionServer{stream})
}

type GeoNameService_SubdivisionServer interface {
	Send(*GeoNameSubdivisionResponse) error
	grpc.ServerStream
}

type geoNameServiceSubdivisionServer struct {
	grpc.ServerStream
}

func (x *geoNameServiceSubdivisionServer) Send(m *GeoNameSubdivisionResponse) error {
	return x.ServerStream.SendMsg(m)
}

// GeoNameService_ServiceDesc is the grpc.ServiceDesc for GeoNameService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GeoNameService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "geoname.GeoNameService",
	HandlerType: (*GeoNameServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Continent",
			Handler:       _GeoNameService_Continent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Country",
			Handler:       _GeoNameService_Country_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "City",
			Handler:       _GeoNameService_City_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subdivision",
			Handler:       _GeoNameService_Subdivision_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/grpc/geoname.proto",
}
